package model

import (
	"database/sql"
	"fmt"
	"log"
	"os"
)

// Database is ...
type Database struct {
	dbConn  *sql.DB
	connStr string
	dbName  string
}

// Init is ...
func (db *Database) Init() {
	db.dbName = os.Getenv("DB_NAME")
	var err error
	db.connStr = fmt.Sprintf("host=localhost user=dev password=pass1234 dbname=%v port=5432 sslmode=disable", db.dbName)
	db.dbConn, err = sql.Open("postgres", db.connStr)
	if err != nil {
		log.Panicf("Connection with db not set, %v", err)
	}
	log.Printf("Connected to %v db!", db.dbName)
	db.createTables()
}

// Getdb is ...
func (db Database) Getdb() *sql.DB {
	return db.dbConn
}

// InsertUser is ...
func (db *Database) InsertUser(userName string, email string) (*User, error) {
	user := User{Username: userName, Email: email}
	resErr, errUser := db.dbConn.Query(`INSERT INTO "user"(user_username, user_email) VALUES ($1, $2) RETURNING user_id;`, userName, email)
	if errUser != nil {
		log.Println("Error inserting user:", errUser)
		return nil, errUser
	}
	defer resErr.Close()
	for resErr.Next() {
		err := resErr.Scan(&user.ID)
		if err != nil {
			return nil, err
		}
	}
	return &user, nil

}

// InsertMeetup is ...
func (db *Database) InsertMeetup(name string, description string) (*Meetup, error) {
	meetup := Meetup{Name: name, Description: description}
	resErr, errMeetup := db.dbConn.Query(`INSERT INTO "meetup"(meetup_name, meetup_description) VALUES($1, $2) RETURNING meetup_id;`, name, description)
	if errMeetup != nil {
		log.Println("Error inserting user:", errMeetup)
		return nil, errMeetup
	}
	defer resErr.Close()
	for resErr.Next() {
		err := resErr.Scan(&meetup.ID)
		if err != nil {
			return nil, err
		}
	}
	return &meetup, nil
}

// UpdateUser is ...
func (db *Database) UpdateUser(user *User) (*User, error) {
	log.Println(user)
	resRow, err := db.dbConn.Query(`UPDATE "user" SET user_username=$1, user_email=$2 WHERE user_id=$3;`, user.Username, user.Email, user.ID)
	if err != nil {
		return user, err
	}
	defer resRow.Close()
	return user, nil
}

//GetMeetups is ...
func (db *Database) GetMeetups() ([]*Meetup, error) {
	resRows, err := db.dbConn.Query(`SELECT * FROM "meetup"`)
	if err != nil {
		return nil, err
	}
	defer resRows.Close()
	listOfMeetups := []*Meetup{}
	for resRows.Next() {
		meetup := Meetup{}
		err := resRows.Scan(&meetup.ID, &meetup.Name, &meetup.Description)
		if err != nil {
			return nil, err
		}
		listOfMeetups = append(listOfMeetups, &meetup)
	}
	return listOfMeetups, nil
}

// GetUsers is ...
func (db *Database) GetUsers() ([]*User, error) {
	resRows, err := db.dbConn.Query(`SELECT * FROM "user"`)
	if err != nil {
		return nil, err
	}
	defer resRows.Close()
	listOfUsers := []*User{}
	for resRows.Next() {
		user := User{}
		err := resRows.Scan(&user.ID, &user.Username, &user.Email)
		if err != nil {
			return nil, err
		}
		listOfUsers = append(listOfUsers, &user)
	}
	return listOfUsers, nil
}

//GetUserWithMeetups is ...
func (db *Database) GetUserWithMeetups(userID *int) (*User, error) {
	resRows, err := db.dbConn.Query(`
		SELECT u.user_email, u.user_id, u.user_username, m.meetup_id, m.meetup_name, m.meetup_description
		FROM "user_meetup" um
		JOIN "user" u ON um.user_id = u.user_id
		JOIN "meetup" m ON um.meetup_id = m.meetup_id
		WHERE um.user_id = $1;
	`, userID)
	if err != nil {
		return nil, err
	}
	defer resRows.Close()
	listOfMeetups := []*Meetup{}
	user := User{}
	for resRows.Next() {
		meetup := Meetup{}
		err := resRows.Scan(&user.Email, &user.ID, &user.Username, &meetup.ID, &meetup.Name, &meetup.Description)
		if err != nil {
			return nil, err
		}
		listOfMeetups = append(listOfMeetups, &meetup)
	}
	user.Meetups = listOfMeetups
	return &user, nil
}

/*InsertUserMeetup -
Used to insert at the same time user and meetup and make the join relation.
*/
func (db *Database) InsertUserMeetup(user User, meetup *Meetup) error {
	query := fmt.Sprintf(`
		BEGIN;
			INSERT INTO "user" (user_username, user_email)
			VALUES ('%v', '%v');

			INSERT INTO "meetup" (meetup_name, meetup_description)
			VALUES ('%v', '%v');

			INSERT INTO "user_meetup"(user_id, meetup_id)
			VALUES(
				(SELECT user_id FROM "user" WHERE user_email='%v'),
				(SELECT meetup_id FROM "meetup" WHERE meetup_name='%v')
			);
		COMMIT;
	`, user.Username, user.Email, meetup.Name, meetup.Description, user.Email, meetup.Name)
	_, err := db.dbConn.Query(query)
	if err != nil {
		log.Println("Error inserting in table user_meetup:", err)
		return err
	}
	return nil
}

func (db Database) createTables() {
	createTableUser := `CREATE TABLE IF NOT EXISTS "user" (
		user_id			int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		user_username	text NOT NULL,
		user_email		text NOT NULL UNIQUE
	);`
	createTableMeetup := `CREATE TABLE IF NOT EXISTS "meetup" (
		meetup_id			int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		meetup_name			text NOT NULL UNIQUE,
		meetup_description	text NOT NULL
	);`
	createRelationTable := `CREATE TABLE IF NOT EXISTS "user_meetup" (
		user_id int NOT NULL,
		meetup_id int NOT NULL,
		FOREIGN KEY (user_id) REFERENCES "user"(user_id) ON UPDATE CASCADE,
		FOREIGN KEY (meetup_id) REFERENCES "meetup"(meetup_id) ON UPDATE CASCADE
	);`
	_, errUser := db.dbConn.Query(createTableUser)
	if errUser != nil {
		log.Fatalf("Error creating table User: %v", errUser)
	}
	_, errMeetup := db.dbConn.Query(createTableMeetup)
	if errMeetup != nil {
		log.Fatal("Error creating table Meetup:", errMeetup)
	}
	_, errRelation := db.dbConn.Query(createRelationTable)
	if errRelation != nil {
		log.Fatal("Error creating table User_Meetup", errRelation)
	}
	log.Println("Table exists previously or just were created!")
}
