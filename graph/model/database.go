package model

import (
	"database/sql"
	"fmt"
	"log"
	"os"
)

// Database is ...
type Database struct {
	dbConn  *sql.DB
	connStr string
	dbName  string
}

// Init is ...
func (db *Database) Init() {
	db.dbName = os.Getenv("DB_NAME")
	var err error
	db.connStr = fmt.Sprintf("host=localhost user=dev password=pass1234 dbname=%v port=5432 sslmode=disable", db.dbName)
	db.dbConn, err = sql.Open("postgres", db.connStr)
	if err != nil {
		log.Panicf("Connection with db not set, %v", err)
	}
	log.Printf("Connected to %v db!", db.dbName)
	db.createTables()
}

// Getdb is ...
func (db Database) Getdb() *sql.DB {
	return db.dbConn
}

// InsertUser is ...
func (db *Database) InsertUser(userName string, email string) {
	_, errUser := db.dbConn.Query(`INSERT INTO "user"(user_username, user_email) VALUES ($1, $2);`, userName, email)
	if errUser != nil {
		log.Println("Error inserting user:", errUser)
	}
}

// InsertMeetup is ...
func (db *Database) InsertMeetup(name string, description string) {
	_, errMeetup := db.dbConn.Query(`INSERT INTO "meetup"(meetup_name, meetup_description) VALUES($1, $2);`, name, description)
	if errMeetup != nil {
		log.Println("Error inserting user:", errMeetup)
	}
}

//GetMeetups is ...
func (db *Database) GetMeetups() ([]*Meetup, error) {
	resRows, err := db.dbConn.Query(`SELECT * FROM "meetup"`)
	if err != nil {
		return nil, err
	}
	defer resRows.Close()
	listOfMeetups := []*Meetup{}
	for resRows.Next() {
		meetup := Meetup{}
		err := resRows.Scan(&meetup.ID, &meetup.Name, &meetup.Description)
		if err != nil {
			return nil, err
		}
		listOfMeetups = append(listOfMeetups, &meetup)
	}
	return listOfMeetups, nil
}

/*InsertUserMeetup -
Used to insert at the same time user and meetup and make the join relation.
*/
func (db *Database) InsertUserMeetup(user User, meetup *Meetup) error {
	query := fmt.Sprintf(`
		BEGIN;
			INSERT INTO "user" (user_username, user_email)
			VALUES ('%v', '%v');

			INSERT INTO "meetup" (meetup_name, meetup_description)
			VALUES ('%v', '%v');

			INSERT INTO "user_meetup"(user_id, meetup_id)
			VALUES(
				(SELECT user_id FROM "user" WHERE user_email='%v'),
				(SELECT meetup_id FROM "meetup" WHERE meetup_name='%v')
			);
		COMMIT;
	`, user.Username, user.Email, meetup.Name, meetup.Description, user.Email, meetup.Name)
	_, err := db.dbConn.Query(query)
	if err != nil {
		log.Println("Error inserting in table user_meetup:", err)
		return err
	}
	return nil
}

func (db Database) createTables() {
	createTableUser := `CREATE TABLE IF NOT EXISTS "user" (
		user_id			int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		user_username	text NOT NULL,
		user_email		text NOT NULL UNIQUE
	);`
	createTableMeetup := `CREATE TABLE IF NOT EXISTS "meetup" (
		meetup_id			int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
		meetup_name			text NOT NULL UNIQUE,
		meetup_description	text NOT NULL
	);`
	createRelationTable := `CREATE TABLE IF NOT EXISTS "user_meetup" (
		user_id int NOT NULL,
		meetup_id int NOT NULL,
		FOREIGN KEY (user_id) REFERENCES "user"(user_id) ON UPDATE CASCADE,
		FOREIGN KEY (meetup_id) REFERENCES "meetup"(meetup_id) ON UPDATE CASCADE
	);`
	_, errUser := db.dbConn.Query(createTableUser)
	if errUser != nil {
		log.Fatalf("Error creating table User: %v", errUser)
	}
	_, errMeetup := db.dbConn.Query(createTableMeetup)
	if errMeetup != nil {
		log.Fatal("Error creating table Meetup:", errMeetup)
	}
	_, errRelation := db.dbConn.Query(createRelationTable)
	if errRelation != nil {
		log.Fatal("Error creating table User_Meetup", errRelation)
	}
	log.Println("Table exists previously or just were created!")
}
